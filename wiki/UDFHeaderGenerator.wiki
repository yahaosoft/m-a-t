#summary For AutoIt
#labels Featured
This is a Lua script based on one by Valik that will create the standard UDF function header when used and the caret is on a function definition line. Thanks also to Wraithdu and Jos for suggestions and fixes :)

=To Install=

Installing has a number of steps that it's better for a human to do, as it may differ slightly between SciTE versions.

  # Open up `AutoItTools.lua`, which can be found at: `%AutoItDir%\SciTE\LUA\AutoItTools.lua`. You are then looking for the line that says `function AutoItTools:CreateFunctionHeader(s)`. You want to replace the two functions `CreateFunctionHeader` and `InsertUDFHeader` with the two here. Replace `defAuthor` while you are there:
{{{
--------------------------------------------------------------------------------
-- CreateFunctionHeader(s)
--
-- Creates the UDF function header from a function definition line.
--
-- Tool: For use by AutoItTools:InsertUDFHeader.
--------------------------------------------------------------------------------
function AutoItTools:CreateFunctionHeader(s)

    -- Change these :)
    local defAuthor = "Matt Diesel (Mat)"    -- Initial Author value

    local defLineMax = 129                   -- Max length of line. AutoIt standard is 129.
    local defSplit = 21                      -- Default index for '-' after param.

    local nl = self:NewLineInUse()

    local outStart   = "FUNCTION"
    local outName    = ""
    local outDesc    = ""
    local outSyntax  = ""
    local outParams  = ""
    local outReturn  = "None"
    local outAuthor  = defAuthor
    local outModify  = ""
    local outRemarks = ""
    local outRelated = ""
    local outLink    = ""
    local outExample = "No"

    local f,t,name,params = s:find("^%s*[Ff][Uu][Nn][Cc]%s+(.+)%s*(%b())")

    outName = name
    if name:sub(0, 2) == "__" then
        outStart = "INTERNAL_USE_ONLY"
    end

    outSyntax = name .. "("

    local paramSynt = ""
    local iOptionals = 0
    local fBroken = false
    if params ~= "" and params ~= nil then
        for byref, parameter, optional in string.gfind(params, "(%w-)%s*($[%w_]+)%s*([=]?)") do
            if parameter ~= "" and parameter ~= nil then
                if outParams ~= "" then
                    outParams = outParams .. nl .. ";" .. string.rep(" ", 18)
                end

                outParams = outParams .. parameter .. string.rep(" ", defSplit - string.len(parameter)) .. "- "

                if optional ~= "" and optional ~= nil then
                    outParams = outParams .. "[optional] "

                    if paramSynt ~= "" then
                        paramSynt = paramSynt .. "[, "
                    else
                        paramSynt = paramSynt .. "["
                    end

                    iOptionals = iOptionals + 1
                else
                    if byref ~= "" and byref ~= nil then
                        outParams = outParams .. "[in/out] "
                    end

                    if paramSynt ~= "" then
                        paramSynt = paramSynt .. ", "
                    end
                end

                if fBroken then
                    if string.len(paramSynt) + string.len(parameter) + iOptionals + 2 + 19 > defLineMax then
                        outSyntax = outSyntax .. paramSynt .. nl .. ";" .. string.rep(" ", 18)
                        paramSynt = ""
                        fBroken = true
                    end
                else
                    if string.len(outSyntax) + string.len(paramSynt) + string.len(parameter) + iOptionals + 2 + 19 > defLineMax then
                        outSyntax = outSyntax .. paramSynt .. nl .. ";" .. string.rep(" ", 18)
                        paramSynt = ""
                        fBroken = true
                    end
                end
                paramSynt = paramSynt .. parameter

                local paramtype = parameter:sub(2, 2)
                local isarray = false
                if paramtype == "a" then
                    paramtype = parameter:sub(3, 3)
                    isarray = true
                end

                local sAdd
                if paramtype == "i" then
                    sAdd = "integer"
                elseif paramtype == "f" then
                    sAdd = "boolean"
                elseif paramtype == "b" then
                    sAdd = "binary"
                elseif paramtype == "n" then
                    sAdd = "floating point number"
                elseif paramtype == "s" then
                    sAdd = "string"
                elseif paramtype == "h" then
                    sAdd = "handle"
                elseif paramtype == "v" then
                    sAdd = "variant"
                elseif paramtype == "p" then
                    sAdd = "pointer"
                elseif paramtype == "t" then
                    sAdd = "dll struct"
                else
                    sAdd = "unknown"
                end

                if isarray then
                    outParams = outParams .. "An array of " .. sAdd .. "s."
                else
                    outParams = outParams .. "A " .. sAdd .. " value."
                end
            end
        end
    else
        outParams = "None"
    end

    outSyntax = outSyntax .. paramSynt .. string.rep("]", iOptionals) .. ")"

    local res = "; #" .. outStart .. "# " .. string.rep("=", defLineMax - 5 - outStart:len()) .. nl
    res = res .. "; Name ..........: " .. outName .. nl
    res = res .. "; Description ...: " .. outDesc .. nl
    res = res .. "; Syntax ........: " .. outSyntax .. nl
    res = res .. "; Parameters ....: " .. outParams .. nl
    res = res .. "; Return values .: " .. outReturn .. nl
    res = res .. "; Author(s) .....: " .. outAuthor .. nl
    res = res .. "; Modified ......: " .. outModify .. nl
    res = res .. "; Remarks .......: " .. outRemarks .. nl
    res = res .. "; Related .......: " .. outRelated .. nl
    res = res .. "; Link ..........: " .. outLink .. nl
    res = res .. "; Example .......: " .. outExample .. nl
    res = res .. "; " .. string.rep("=", defLineMax - 2) .. nl

    return res
end -- CreateFunctionHeader()

--------------------------------------------------------------------------------
-- InsertUDFHeader
--
-- Inserts a UDF header for the line the cursor is currently on.
--
-- Tool: AutoItTools:InsertUDFHeader $(au3) Alt+U Make header
--------------------------------------------------------------------------------
function AutoItTools:InsertUDFHeader()
    local line, pos = editor:GetCurLine()
    local pos = editor.CurrentPos - pos
    local lineNum = editor:LineFromPosition(pos)
    local from, to = line:find("[Ff][Uu][Nn][Cc][%s]*([%w%s_]*)")
    if to ~= nil then
        -- remove comments
        from, to =  line:find(";")
        while from ~= nil do
            if editor.StyleAt[pos+from] == SCE_AU3_COMMENT then
                line = string.sub (line, 1 , from-1)   -- remove comment
                from = nil                             -- exit loop
            else
                from, to =  line:find(";",from+1)      -- find next ; as this one is not a comment
            end
        end

        local pfrom, pto = line:find("%(")    -- check for opening parenthesis
        local i = 0
        if pto ~= nil then
            while line:find("%s+_%s*$") do    -- found a line continuation
                line = line:gsub("%s+_%s*$", "")    -- remove it
                i = i + 1
                local tmp = editor:GetLine(lineNum+i)
                tmp = tmp:gsub("^%s*", "")    -- remove leading white space
                tmp = tmp:gsub("%s*;.*$", "")    -- remove comments
                line = line .. tmp
            end
            editor:Home()
            line = line:gsub("[\r\n]", "")    -- remove line breaks
            editor:AddText(self:CreateFunctionHeader(line))
        else
            print("Argument list not found, unable to insert header.")
        end
    else
		from, to = line:find("[Gg][Ll][Oo][Bb][Aa][Ll]%s+[Cc][Oo][Nn][Ss][Tt]%s+$[Tt][Aa][Gg](%w+)%s*=%s*\"(.+)\"")
		if to ~= nil then
			-- It's a structure
			print("Not implemented: Structures")
		else
			print("Function or struct definition not found, unable to insert header.")
		end
    end
end -- InsertFunctionHeader()
}}}
  # Next you need to add it to the tools list. To do that open up `au3.properties` (the easiest way is from SciTE by going to the Options menu). It doesn't matter where too much, but I usually insert the following code just before the line that says `# Commands to for Help F1` (I'm not sure what that lines supposed to say btw). If the number `42` happens to be taken, just replace it with a new vacant number.
{{{
# 42 Generate UDF header
command.name.42.$(au3)=Make Header
command.mode.42.$(au3)=subsystem:lua,savebefore:no
command.shortcut.42.$(au3)=Alt+U
command.42.$(au3)=InvokeTool AutoItTools.InsertUDFHeader
}}}
  # The tool should now show up in the menu... Try it on a function definition statement and see.

Mat